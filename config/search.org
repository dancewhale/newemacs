#+description: config for search and complete. 
#+auto_tangle: vars:org-babel-tangle-comment-format-beg:org-babel-tangle-comment-format-end t
#+property:    header-args:emacs-lisp  :tangle yes

A literate programming file for search/complete package and configure.

#+begin_src emacs-lisp :exports none
  ;;; search --- setting config and package for search/complete -*- lexical-binding: t; -*-
  ;;
  ;; © 2025 dancewhale
  ;;   This work is licensed under a Creative Commons Attribution 4.0 International License.
  ;;   See http://creativecommons.org/licenses/by/4.0/
  ;;
  ;; Author: dancewhale <http://gitlab.com/dancewhale>
  ;; Maintainer: dancewhale
  ;; Created: Dec 22, 2025
  ;;
  ;; While obvious, GNU Emacs does not include this file or project.
  ;;
  ;; *NB:* Do not edit this file. Instead, edit the original literate file at:
  ;;            /Users/dancewhale/other/hamacs/cyz-leader.org
  ;;       And tangle the file to recreate this one.
  ;;
  ;;; Code:
#+end_src

* Search Operations
Ways to search for information goes under the ~s~ key. The venerable sage has always been =grep=, but we now have new-comers, like [[https://github.com/BurntSushi/ripgrep][ripgrep]], which are really fast.
** ripgrep
Install the [[https://github.com/dajva/rg.el][rg]] package, which builds on the internal =grep= system, and creates a =*rg*= window with =compilation= mode, so ~C-j~ and ~C-k~ will move and show the results by loading those files.

#+begin_src emacs-lisp
  (use-package rg
    :config
    ;; Make an interesting Magit-like menu of options, which I don't use much:
    (rg-enable-default-bindings (kbd "M-R"))

    (cyz-leader
      "s"  '(:ignore t :which-key "search")
      "s q" '("close" . cyz-rg-close-results-buffer)
      "s r" '("dwim" . rg-dwim)
      "s s" '("search" . rg)
      "s S" '("literal" . rg-literal)
      "s p" '("project" . rg-project)
      "s d" '("directory" . rg-dwim-project-dir)
      "s f" '("file only" . rg-dwim-current-file)
      "s j" '("next results" . cyz-rg-go-next-results)
      "s k" '("prev results" . cyz-rg-go-previous-results)
      "s b" '("results buffer" . cyz-rg-go-results-buffer)

      "s <escape>" '(keyboard-escape-quit :which-key t)
      "s C-g" '(keyboard-escape-quit :which-key t))

    (defun cyz-rg-close-results-buffer ()
      "Close to the `*rg*' buffer that `rg' creates."
      (interactive)
      (kill-buffer "*rg*"))

    (defun cyz-rg-go-results-buffer ()
      "Pop to the `*rg*' buffer that `rg' creates."
      (interactive)
      (pop-to-buffer "*rg*"))

    (defun cyz-rg-go-next-results ()
      "Bring the next file results into view."
      (interactive)
      (cyz-rg-go-results-buffer)
      (next-error-no-select)
      (compile-goto-error))

    (defun cyz-rg-go-previous-results ()
      "Bring the previous file results into view."
      (interactive)
      (cyz-rg-go-results-buffer)
      (previous-error-no-select)
      (compile-goto-error)))
#+end_src
Note we bind the key ~M-R~ to the [[help:rg-menu][rg-menu]], which is a Magit-like interface to =ripgrep=.

I don’t understand the bug associated with the =:general= extension to =use-package=, but it /works/, but stops everything else from working, so pulling it out into its own =use-package= section addresses that issue:
#+begin_src emacs-lisp
  (use-package rg
    :general (:states 'normal "gS" 'rg-dwim))
#+end_src
** wgrep
The [[https://github.com/mhayashi1120/Emacs-wgrep][wgrep package]] integrates with =ripgrep=. Typically, you hit ~i~ to automatically go into =wgrep-mode= and edit away, but since I typically want to edit everything at the same time, I have a toggle that should work as well:
#+begin_src emacs-lisp
  (use-package wgrep
    :after rg
    :commands wgrep-rg-setup
    :hook (rg-mode-hook . wgrep-rg-setup)
    :config
    (cyz-leader
      :keymaps 'rg-mode-map  ; Actually, `i' works!
      "s w" '("wgrep-mode" . wgrep-change-to-wgrep-mode)
      "t w" '("wgrep-mode" . wgrep-change-to-wgrep-mode)))
#+end_src
** blink-search
#+name: blink-search
#+begin_src emacs-lisp  :comments link
  (straight-use-package
    '(blink-search
      :host github
      :repo "manateelazycat/blink-search"
      :files ("./*.el" "./*.py" ("core" . "core") ("backend" . "backend") 
                                   ("icons" . "icons"))))

  (use-package blink-search
    :commands (blink-search)
    :init
    (setq blink-search-browser-function
          (if (display-graphic-p)
              #'xwidget-webkit-browse-url
            #'eww)
          blink-search-enable-posframe t))
#+end_src


* Consult
The [[https://github.com/minad/consult][consult project]] aims to use libraries like [[*Vertico][Vertico]] to enhance specific, built-in, Emacs functions. I appreciate this project that when selecting an element in the minibuffer, it displays what you are looking at… for instance, it previews a buffer before choosing it. Unlike /Vertico/ and /Orderless/, you need to bind keys to its special functions (or rebind existing keys that do something similar).

#+begin_src emacs-lisp
  (use-package consult
    :after general
    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    :bind (("s-v" . consult-yank-pop)
           ("M-X" . consult-mode-command)) ; Hrm...

    :general
    (:states 'normal
             "gp" '("preview paste" . 'consult-yank-pop)
             "gs" '("go to line" . 'consult-line)))
#+end_src

I found the =consult-mark= as part of [[https://arialdomartini.github.io/emacs-mark-ring][this essay]] about the =mark=.

Let’s show =consult-xref= for two functions:
#+begin_src emacs-lisp
  (use-package consult
    :config
    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref))
#+end_src

We sprinkle Consult features throughout the leader menu system:

#+begin_src emacs-lisp
  (use-package consult
    :config
    (cyz-leader
      "RET" '("bookmark"            . consult-bookmark)
      "k"   '("marks"               . consult-mark)
      "K"   '("global marks"        . consult-global-mark)
      "b b" '("switch"              . consult-buffer)
      "b B" '("proj switch"         . consult-project-buffer)
      "b o" '("switch win"          . consult-buffer-other-window)
      "f g" '("find grep"           . consult-ripgrep)
      "h I" '("info manual"         . consult-info)
      "h O" '("org info"            . (lambda () (interactive) (consult-info "org")))
      "h M" '("man pages"           . consult-man)
      "t m" '("minor mods"          . consult-minor-mode-menu)
      "x i" '("choose from imenu"   . consult-imenu)
      "x I" '("choose from outline" . consult-outline)
      "x r" '("registers"           . consult-register)
      "x y" '("preview yank"        . consult-yank-pop)))
#+end_src

An under-appreciated version of Consult is the /changing your mind/ aspect. Type ~SPC b b~ to switch to a different buffer, and change your mind, “oh, I really need a file!” Type ~f SPC~ and it switches to a file browser. Nope, I did need the buffer, type ~b SPC~ and your back to buffer switching. Other /narrowing/ keys:

    - ~b~ :: Buffers
    - ~SPC~ :: Hidden buffers
    - ~*~ :: Modified buffers
    - ~f~ :: Files (Requires recentf-mode)
    - ~r~ :: File registers
    - ~m~ :: Bookmarks
    - ~p~ :: Project

* Completion
** Vertico
#+name: vertico
#+begin_src emacs-lisp :comments link
;  (straight-use-package 'vertico)
;  (setq vertico-cycle t)
;  (vertico-mode)
#+end_src

** ivy
#+name: pacakge install
#+begin_src emacs-lisp :comments link
   (straight-use-package 'ivy)
   (straight-use-package 'swiper)
   (straight-use-package 'ivy-hydra)
   (straight-use-package 'ivy-avy)
   (straight-use-package 'counsel)
   (straight-use-package 'ivy-rich)
   (straight-use-package 'ivy-prescient)
   (straight-use-package 'wgrep)
   (straight-use-package 'ivy-posframe)
   (straight-use-package 'nerd-icons-ivy-rich)

  (ivy-mode)
  (ivy-prescient-mode)
  (setq ivy-use-virtual-buffers t)
  (setq enable-recursive-minibuffers t)
  (general-define-key
  "M-x"     'counsel-M-x
  "s-x"     'counsel-M-x
  "C-x C-f" 'counsel-find-file
  "C-c C-o" 'ivy-occur
  "C-s"     'swiper
  "C-c C-r" 'ivy-resume
  "C-c g"   'counsel-git
  "C-c j"   'counsel-git-grep
  "C-c k"   'counsel-ag
  "C-x l"   'counsel-locate
  "C-S-o"   'counsel-rhythmbox
  )

#+end_src

** Yasnippet
#+name: yasnippet
#+begin_src emacs-lisp :comments link
  (straight-use-package 'yasnippet)
  (setq yas-snippet-dirs (list "~/.emacs.d/snippets"))
  (yas-global-mode)
#+end_src

* Embark
The [[https://github.com/oantolin/embark/][embark]] project offers /actions/ on /targets/. I'm primarily thinking of acting on selected items in the minibuffer, but these commands act anywhere.  I need an easy-to-use keybinding that doesn't conflict. Hey, that is what the Super key is for, right?

#+begin_src emacs-lisp
  (use-package embark
    :bind
    (("s-'" . embark-act)               ; Work in minibuffer and elsewhere
     ("s-/" . embark-dwim))

    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    :config
    (cyz-leader "h K" '("keybindings" . embark-bindings)))
#+end_src

In [[https://karthinks.com/software/fifteen-ways-to-use-embark/][15 Ways to Use Embark]], Karthik Chikmagalur suggests a nifty macro for integrating Embark with [[Ace Window][Ace Window]]:

#+begin_src emacs-lisp
  (use-package embark
    :after ace-window
    :config
    (defmacro my/embark-ace-action (fn)
      `(defun ,(intern (concat "my/embark-ace-" (symbol-name fn))) ()
         (interactive)
         (with-demoted-errors "%s"
           (require 'ace-window)
           (let ((aw-dispatch-always t))
             (aw-switch-to-window (aw-select nil))
             (call-interactively (symbol-function ',fn))))))

    (defmacro my/embark-split-action (fn split-type)
      `(defun ,(intern (concat "my/embark-"
                               (symbol-name fn)
                               "-"
                               (car (last  (split-string
                                            (symbol-name split-type) "-"))))) ()
         (interactive)
         (funcall #',split-type)
         (call-interactively #',fn)))

    ;; Use the macros to define some helper functions:
    (my/embark-ace-action find-file)                             ; --> my/embark-ace-find-file
    (my/embark-ace-action switch-to-buffer)                      ; --> my/embark-ace-switch-to-buffer
    (my/embark-ace-action bookmark-jump)                         ; --> my/embark-ace-bookmark-jump
    (my/embark-split-action find-file split-window-below)        ; --> my/embark-find-file-below
    (my/embark-split-action find-file split-window-right)        ; --> my/embark-find-file-right
    (my/embark-split-action switch-to-buffer split-window-below) ; --> my/embark-switch-to-buffer-below
    (my/embark-split-action switch-to-buffer split-window-right) ; --> my/embark-switch-to-buffer-right
    (my/embark-split-action bookmark-jump split-window-below)    ; --> my/embark-bookmark-jump-below
    (my/embark-split-action bookmark-jump split-window-right))   ; --> my/embark-bookmark-jump-right
#+end_src

We can rebind the various =embark-xyz-map= with calls to our macroized functions:
#+begin_src emacs-lisp
  (use-package embark
    :bind
    (:map embark-file-map
     ("y" . embark-copy-as-kill)
     ("Y" . embark-save-relative-path)
     ("W" . nil)
     ("w" . my/embark-ace-find-file)
     ("2" . my/embark-find-file-below)
     ("3" . my/embark-find-file-right)
     :map embark-buffer-map
     ("y" . embark-copy-as-kill)
     ("w" . my/embark-ace-switch-to-buffer)
     ("2" . my/embark-switch-to-buffer-below)
     ("3" . my/embark-switch-to-buffer-right)
     :map embark-file-map
     ("y" . embark-copy-as-kill)
     ("w" . my/embark-ace-bookmark-jump)
     ("2" . my/embark-bookmark-jump-below)
     ("3" . my/embark-bookmark-jump-right)))
#+end_src

According to [[https://elpa.gnu.org/packages/embark-consult.html#orgc76b5de][this essay]], Embark cooperates well with the [[https://github.com/minad/marginalia][Marginalia]] and [[https://github.com/minad/consult][Consult]] packages. Neither of those packages is a dependency of Embark, but Embark supplies a hook for Consult where Consult previews can be done from Embark Collect buffers:

#+begin_src emacs-lisp
  (use-package embark-consult
    :after (embark consult)
    :demand t ; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

According to the [[https://elpa.gnu.org/packages/embark-consult.html][Embark-Consult page]]:
#+begin_quote
Users of the popular [[https://github.com/justbur/emacs-which-key][which-key]] package may prefer to use the =embark-which-key-indicator= from the [[https://github.com/oantolin/embark/wiki/Additional-Configuration#use-which-key-like-a-key-menu-prompt][Embark wiki]]. Just copy its definition from the wiki into your configuration and customize the =embark-indicators= user option to exclude the mixed and verbose indicators and to include =embark-which-key-indicator=.
#+end_quote
In other words, typing ~s-.~ to call Embark, specifies the options in a buffer, but the following code puts them in a smaller configuration directly above the selections.

#+begin_src emacs-lisp
  (defun embark-which-key-indicator ()
    "An embark indicator that displays keymaps using which-key.
  The which-key help message will show the type and value of the
  current target followed by an ellipsis if there are further
  targets."
    (lambda (&optional keymap targets prefix)
      (if (null keymap)
          (which-key--hide-popup-ignore-command)
        (which-key--show-keymap
         (if (eq (plist-get (car targets) :type) 'embark-become)
             "Become"
           (format "Act on %s '%s'%s"
                   (plist-get (car targets) :type)
                   (embark--truncate-target (plist-get (car targets) :target))
                   (if (cdr targets) "…" "")))
         (if prefix
             (pcase (lookup-key keymap prefix 'accept-default)
               ((and (pred keymapp) km) km)
               (_ (key-binding prefix 'accept-default)))
           keymap)
         nil nil t (lambda (binding)
                     (not (string-suffix-p "-argument" (cdr binding))))))))

  (setq embark-indicators
        '(embark-which-key-indicator
          embark-highlight-indicator
          embark-isearch-highlight-indicator))

  (defun embark-hide-which-key-indicator (fn &rest args)
    "Hide the which-key indicator immediately when using the completing-read prompter."
    (which-key--hide-popup-ignore-command)
    (let ((embark-indicators
           (remq #'embark-which-key-indicator embark-indicators)))
      (apply fn args)))

  (advice-add #'embark-completing-read-prompter
              :around #'embark-hide-which-key-indicator)
#+end_src

* Technical Artifacts                                :noexport:

Let's =provide= a name so we can =require= this file:

#+begin_src emacs-lisp :exports none
  (provide 'search)
  ;;; search.el ends here
#+end_src
