#+title:  Emacs Lisp Configuration
#+author: Dancewhale
#+date:   2022-05-11
#+tags: emacs programming lisp

#+description: configuring Emacs for Lisp programming.
#+property:    header-args:emacs-lisp  :tangle yes
#+auto_tangle: vars:org-babel-tangle-comment-format-beg:org-babel-tangle-comment-format-end t

A literate programming file for configuring Emacs for Lisp programming.

#+begin_src emacs-lisp :comments link :exports none
;;; czy-lisp --- configuring Emacs for Lisp programming. -*- lexical-binding: t; -*-
;;
;; Â© 2022-2023 Dancewhale
;;   Licensed under a Creative Commons Attribution 4.0 International License.
;;   See http://creativecommons.org/licenses/by/4.0/
;;
;; Author: Howard X. Abrams <http://gitlab.com/howardabrams>
;; Maintainer: Dancewhale
;; Created: May 11, 2022
;;
;; This file is not part of GNU Emacs.
;;
;; *NB:* Do not edit this file. Instead, edit the original literate file at:
;;            /Users/howard.abrams/other/hamacs/czy-lisp.org
;;       And tangle the file to recreate this one.
;;
;;; Code:
  #+end_src

* Introduction
ç”¨æ¥é…ç½®elisp çš„ç›¸å…³é…ç½®.
* Major Mode Hydra
All the above loveliness can be easily accessible with a [[https://github.com/jerrypnz/major-mode-hydra.el][major-mode-hydra]] defined for =emacs-lisp-mode=:

#+begin_src emacs-lisp :comments link
(use-package major-mode-hydra
  :config
  (major-mode-hydra-define emacs-lisp-mode nil
    ("Evaluating"
     (("e" czy-eval-current-expression "Current")
      ("d" lispy-debug/body "Debugging")
      ("f" eval-defun "Function")
      ("b" eval-buffer "Buffer"))
     "Editing"
     (("r" lisp-refactor/body "Refactoring"))
     "Documentation"
     (("a" elisp-demos-add-demo "Add Demo")
      ("H" suggest "Suggestions")))))
#+end_src
* Syntax Display
** Dim those Parenthesis
The [[https://github.com/tarsius/paren-face][paren-face]] project lowers the color level of parenthesis which I find better.

#+begin_src emacs-lisp :comments link
  (use-package paren-face
    :hook (emacs-lisp-mode . paren-face-mode))
#+end_src

Show code examples with the [[https://github.com/xuchunyang/elisp-demos][elisp-demos]] package.
#+begin_src emacs-lisp :comments link
  (use-package elisp-demos
    :config
    (advice-add 'describe-function-1 :after #'elisp-demos-advice-describe-function-1))
#+end_src

** Helpful Functions
Letâ€™s take advantage of [[https://github.com/Wilfred/helpful][helpful]] package for getting more information into the =describe-function= call.

#+begin_src emacs-lisp :comments link
(use-package helpful)

(general-define-key
   "C-h f"  #'helpful-callable
   "C-h v"  #'helpful-variable
   "C-h F"  #'helpful-function
   "C-h s"  #'helpful-symbol
   "C-h k"  #'helpful-key
   "C-h x"  #'helpful-command
   "C-h C-d"  #'helpful-at-point
   )
#+end_src

And we should extend it with the [[https://github.com/xuchunyang/elisp-demos][elisp-demos]] project:

#+begin_src emacs-lisp :comments link
(use-package elisp-demos
  :after helpful
  :config
  (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
#+end_src

Find a function without a good demonstration? Call =elisp-demos-add-demo=.

Wilfredâ€™s [[https://github.com/Wilfred/suggest.el][suggest]] function helps you find the right function. Basically, you type in the parameters of a function, and then the desired output, and it will write the function call.

#+begin_src emacs-lisp :comments link
(use-package suggest)
#+end_src

* Navigation
** Goto Definitions
Wilfredâ€™s [[https://github.com/Wilfred/elisp-def][elisp-def]] project does a better job at jumping to the definition of a symbol at the point, so:
#+begin_src emacs-lisp :comments link
(use-package elisp-def
  :hook (emacs-lisp-mode . elisp-def-mode))
#+end_src
This /should work/ with [[help:evil-goto-definition][evil-goto-defintion]], as that calls this list from [[help:evil-goto-definition-functions][evil-goto-definition-functions]]:
  - [[help:evil-goto-definition-imenu][evil-goto-definition-imenu]]
  - [[help:evil-goto-definition-semantic][evil-goto-definition-semantic]]
  - [[help:evil-goto-definition-xref][evil-goto-definition-xref]] â€¦ to show what calls a function
  - [[help:evil-goto-definition-search][evil-goto-definition-search]]

While I love packages that add functionality and I donâ€™t have to learn anything, Iâ€™m running into an issue where I do a lot of my Emacs Lisp programming in org files, and would like to jump to the function definition /defined in the org file/. Since [[https://github.com/BurntSushi/ripgrep][ripgrep]] is pretty fast, Iâ€™ll call it instead of attempting to build a [[https://stackoverflow.com/questions/41933837/understanding-the-ctags-file-format][CTAGS]] table. Oooh, the =rg= takes a =â€”json= option, which makes it easier to parse.

#+begin_src emacs-lisp :comments link :tangle no
(defun czy-org-code-block-jump (str pos)
  "Go to a literate org file containing a symbol, STR.
The POS is ignored."
  ;; Sometimes I wrap a function name in `=' characters, and these should be removed:
  (when (string-match (rx "=" (group (one-or-more any)) "=") str)
    (setq str (match-string 1 str)))
  ;; In an org-file, a function may pick up the initial #'
  (when (string-match (rx (optional "#") (optional "'" ) (group (one-or-more any))) str)
    (setq str (match-string 1 str)))
  (ignore-errors
    (let* ((default-directory (project-root (project-current)))
           (command (format "rg --json '\\(def[^ ]+ %s ' *.org" str))
           (results (thread-last command
                                 shell-command-to-list
                                 second
                                 json-parse-string))
           (file    (thread-last results
                                 (gethash "data")
                                 (gethash "path")
                                 (gethash "text")))
           (line    (thread-last results
                                 (gethash "data")
                                 (gethash "line_number"))))
      (find-file file)
      (goto-line line))))

(if (boundp 'evil-goto-definition-functions)
    (add-to-list 'evil-goto-definition-functions 'czy-org-code-block-jump)
  (add-to-list 'xref-backend-functions 'czy-org-code-block-jump))
#+end_src

* Editing
** Lispy
I like the idea of [[https://github.com/abo-abo/lispy][lispy]] for making a Lisp-specific /keybinding state/ (similar to Evil).

My primary use-case is for its refactoring and other unique features. For instance, I love [[help:lispy-ace-paren][lispy-ace-paren]] that puts an /ace label/ on every parenthesis, allowing me to quickly jump to any s-expression.

#+begin_src emacs-lisp :comments link
(use-package lispy
  :config
  (when (fboundp 'evil-define-key)
    (evil-define-key '(normal visual) lispyville-mode-map
      ;; Jump to interesting places:
      "gf" '("ace paren"  . lispy-ace-paren)
      "gF" '("ace symbol" . lispy-ace-symbol)
      (kbd "M-v") '("mark s-exp" . lispy-mark)))   ; Mark entire s-expression

  (pretty-hydra-define lispy-debug nil
    ("Debug"
     (("d" lispy-edebug "Start")
      ("j" lispy-debug-step-in "Jump in")
      ("r" lispy-eval-and-replace "Eval/Replace"))
     "Instrument"
     (("f" (eval-defun t) "Function"))
     ))

  (pretty-hydra-define lisp-refactor nil
    ("To"
     (("i" lispy-to-ifs "condâ†’if")
      ("c" lispy-to-cond "ifâ†’cond")
      ("t" lispy-toggle-thread-last "to thread")
      ("d" lispy-to-defun "Î»â†’ð‘“")
      ("l" lispy-to-lambda "ð‘“â†’Î»"))
     "Convert"
     (("F" lispy-flatten "flatten")
      ("b" lispy-bind-variable "bind var")
      ("B" lispy-unbind-variable "unbind var")))))
#+end_src

** Refactoring
Wilfredâ€™s [[https://github.com/Wilfred/emacs-refactor/tree/master#elisp][emacs-refactor]] package can be helpful if you turn on =context-menu-mode= and â€¦
#+begin_src emacs-lisp :comments link
(use-package emr
  ;; :straight (:host github :repo "Wilfred/emacs-refactor")
  :config
  (pretty-hydra-define+ lisp-refactor nil
    ("To ð›Œ"
     (;; Often know what functions are available:
      ("a" emr-show-refactor-menu "all")
      ;; Extracts the current s-expression or region to function:
      ("f" emr-el-extract-function "to function")
      ("v" emr-el-extract-variable "to variable")
      ;; Converts the current let to a let*
      ("*" emr-el-toggle-let* "toggle let*")
      ;; asks for a variable, and extracts the code in a region
      ;; or the current s-expression, into the nearest let binding
      ("L" emr-el-extract-to-let "to let")))))

#+end_src

The idea of stealing some of Clojure Modeâ€™s refactoring is brilliant (see [[https://isamert.net/2023/08/14/elisp-editing-development-tips.html#clojure-thread-lastfirst-all-from-https-github-com-clojure-emacs-clojure-mode-clojure-mode][the original idea]]), however, Iâ€™m already using Lispyâ€™s =toggle-thread-last=.
#+begin_src emacs-lisp :comments link :tangle no
(use-package clojure-mode
  :general
  (:states '(normal visual) :keymaps 'emacs-lisp-mode-map
           ", r >" '("to thread last" . clojure-thread-last-all)
           ", r <" '("to thread first" . clojure-first-last-all)))
#+end_src
* Evaluation
** Eval Current Expression with eros
The [[https://github.com/xiongtx/eros][eros]] package stands for Evaluation Result OverlayS for Emacs Lisp, and basically shows what each s-expression is near the cursor position instead of in the mini-buffer at the bottom of the window.
#+begin_src emacs-lisp :comments link
(use-package eros
  :hook (emacs-lisp-mode . eros-mode))
#+end_src

A feature I enjoyed from Spacemacs is the ability to evaluate the s-expression currently containing the point. Not sure how they made it, but Lispyville has a =lispyville-next-closing= function to jump to that closing paren (allowing a call to =eval-last-sexp=), and if I save the position using =save-excursion=, I get this feature.

#+begin_src emacs-lisp :comments link
(defun czy-eval-current-expression ()
  "Evaluates the expression the point is currently 'in'.
It does this, by jumping to the end of the current
expression (using evil-cleverparens), and evaluating what it
finds at that point."
  (interactive)
  (save-excursion
    (if (region-active-p)
        (eval-region (region-beginning) (region-end))

      (sp-end-of-sexp)
      (if (fboundp 'eros-eval-last-sexp)
          (call-interactively 'eros-eval-last-sexp)
        (call-interactively 'eval-last-sexp)))))
#+end_src
** Use eros when Edebug
#+begin_src emacs-lisp  :comments link
(defun adviced:edebug-previous-result (_ &rest r)
  "Adviced `edebug-previous-result'."
  (eros--make-result-overlay edebug-previous-result
    :where (point)
    :duration eros-eval-result-duration))

(advice-add #'edebug-previous-result
            :around
            #'adviced:edebug-previous-result)

    #+end_src
* Profiler
å®‰è£…entrace è¿›è¡Œæ—¶é—´åˆ†æž,ä»¥æ”¹è¿›ä»£ç .
#+name: tracer
#+begin_src emacs-lisp  :comments link
(straight-use-package '(etrace :type git :host github :repo "aspiers/etrace"))
(require 'etrace)
#+end_src


* Technical Artifacts                                :noexport:
Let's =provide= a name so we can =require= this file:

#+begin_src emacs-lisp :comments link :exports none
(provide 'czy-programming-elisp)
;;; czy-programming-elisp.el ends here
  #+end_src
