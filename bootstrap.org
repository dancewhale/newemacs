#+title:  My Emacs Bootstrap
#+author: Dancewhale
#+date:   2024-09-10
#+tags: emacs
#+auto_tangle: vars:org-babel-tangle-comment-format-beg:org-babel-tangle-comment-format-end t
#+property:    header-args:emacs-lisp  :tangle yes


A literate programming file for bootstraping my Emacs Configuration.

#+begin_src emacs-lisp :exports none
  ;;; bootstrap.el --- file for bootstraping my Emacs Configuration
  ;;
  ;; © 2024-2024 Dancewhale
  ;;   Licensed under a Creative Commons Attribution 4.0 International License.
  ;;   See http://creativecommons.org/licenses/by/4.0/
  ;;
  ;; Author: Dancewhale
  ;; Maintainer: Dancewhale
  ;;
  ;; This file is not part of GNU Emacs.
  ;;
  ;; *NB:* Do not edit this file. Instead, edit the original literate file at:
  ;;            ~/other/emacs.d/bootstrap.org
  ;;       And tangle the file to recreate this one.
  ;;
  ;;; Code:
#+end_src

* 介绍
这个文件包含了初始化代码,用于引导load 其他的文学编程文件,初始化公共变量和函数.

* 初始化配置
** 载入其他代码保存路径
#+begin_src emacs-lisp :comments link
(add-to-list 'load-path (file-truename "~/.emacs.d/elisp"))
(add-to-list 'load-path (file-truename "~/.emacs.d/doom-lisp"))
#+end_src
** 启动emacs后端服务
#+begin_src emacs-lisp :comments link
(require 'server)
(unless (server-running-p)
  (server-start))
#+end_src


*** OS Path and Native Compilation
Helper functions to allow code for specific operating systems:
#+begin_src emacs-lisp :comments link
(defun cyz-running-on-macos? ()
  "Return non-nil if running on Mac OS systems."
  (equal system-type 'darwin))

(defun cyz-running-on-linux? ()
  "Return non-nil if running on Linux systems."
  (equal system-type 'gnu/linux))
#+end_src

从gui 启动的,往往没有path 等参数配置,通过exec-path-from-shell 导入系统的环境变量.
#+begin_src emacs-lisp :comments link
  (straight-use-package 'exec-path-from-shell)
  (require 'exec-path-from-shell)
  (exec-path-from-shell-initialize)
#+end_src

In Mac  we should unset all super keybind, For my personal super keybind.

#+begin_src emacs-lisp :comments link
(defun global-unset-all-super-key ()
  "Will unset any single key in global keymap that has the super
modifier."
  (let ((km (current-global-map)))
    (while km
      (let ((maybe-event (and (listp (car km))
                              (caar km))))
        (if (and (eventp maybe-event) ; Also filters maybe-event when
                                      ; nil because (car km) was not a list.
                 (memq 'super (event-modifiers maybe-event)))
            (global-unset-key (vector maybe-event))))
      (setq km (cdr km)))))
#+end_src


Clear up a Mac-specific issue that sometimes arises since I'm switching to [[http://akrl.sdf.org/gccemacs.html][native compilation project]], as the =Emacs.app= that I use doesn't have its =bin= directory, e.g. =Emacs.app/Contents/MacOS/bin=:

#+begin_src emacs-lisp :comments link
(when (cyz-running-on-macos?)
    (add-to-list 'exec-path "/usr/local/bin")
    (add-to-list 'exec-path "/opt/homebrew/bin")
    (add-to-list 'exec-path (concat invocation-directory "bin") t)
    (setq lsp-bridge-python-command "/opt/homebrew/Caskroom/miniconda/base/bin/python3")
    (global-unset-all-super-key)

    ;; Keybonds
    (global-set-key [(super a)] 'mark-whole-buffer)
    (global-set-key [(super v)] 'yank)
    (global-set-key [(super c)] 'kill-ring-save)
    (global-set-key [(super s)] 'save-buffer)
    (global-set-key [(super z)] 'undo)
    
    ;; mac switch meta key
    (setq mac-option-modifier 'meta)
    (setq mac-command-modifier 'super)
)
#+end_src

Getting tired off all the packages that I load spewing a bunch of warnings that I can't do anything about:
#+begin_src emacs-lisp :comments link
(when (and (fboundp 'native-comp-available-p)
           (native-comp-available-p))
  (setq native-comp-async-report-warnings-errors nil
        native-comp-deferred-compilation t))
#+end_src


* Basic Libraries
The following packages come with Emacs, but seems like they still need loading:
#+begin_src emacs-lisp :comments link
(use-package cl-lib
  :straight (:type built-in)
  :init (defun first (elt) (car elt))
  :commands (first))

(require 'subr-x)
#+end_src
Ugh. Why am I getting a missing =first= function error? I define a simple implementation, that the CL library will overwrite ... at some point.

While most libraries will take care of their dependencies, I want to install /my dependent libraries/, e.g, [[https://github.com/magnars/.emacs.d/][Magnar Sveen]]'s Clojure-inspired [[https://github.com/magnars/dash.el][dash.el]] project:
#+begin_src emacs-lisp :comments link
(use-package dash)
#+end_src
Sure this package is essentially syntactic sugar, and to help /share/ my configuration, I attempt to use =thread-last= instead of =->>=, but, I still like it.

The [[https://github.com/magnars/s.el][s.el]] project is a simpler string manipulation library that I (and other projects) use:
#+begin_src emacs-lisp :comments link
(use-package s)
#+end_src

Manipulate file paths with the [[https://github.com/rejeep/f.el][f.el]] project:
#+begin_src emacs-lisp :comments link
  (use-package f)
#+end_src

The [[help:shell-command][shell-command]] function is useful, but having it split the output into a list is a helpful abstraction:
#+begin_src emacs-lisp :comments link
(defun shell-command-to-list (command)
  "Return list of lines from running COMMAND in shell."
  (thread-last command
     shell-command-to-string
     s-lines
     (seq-map 's-trim)
     (seq-remove 's-blank-str?)))
#+end_src

And let’s see the results:
#+begin_src emacs-lisp :tangle no :comments link
(ert-deftest shell-command-to-list-test ()
  (should (equal '("hello world")
                 (shell-command-to-list "echo hello world")))

  ;; We don't need blank lines:
  (should (equal '("hello world" "goodbye for now")
                 (shell-command-to-list "echo '\n\nhello world\n\ngoodbye for now\n\n'"))

  ;; No output? Return null:
  (should (null (shell-command-to-list "echo")))

  ;; No line should contain carriage returns:
  (should (null (seq-filter
                 (lambda (line) (s-contains? "\n" line))
                 (shell-command-to-list "ls")))))
#+end_src


 
* Load the Rest
The following /defines/ the rest of my org-mode literate files, that I load later with the =cyz-emacs-load= function:
#+begin_src emacs-lisp :comments link
  (defvar cyz-emacs-files (flatten-list
  			   `("config/init.org"
  			     "config/general.org"
  			     "config/display.org"
  			     "config/programming.org"
  			     "config/programming-elisp.org"
  			     "config/programming-golang.org"
  			     "config/programming-python.org"
  			     "config/memo-learn.org"
  			     "config/chinese.org"
  			     "config/org.org"
  			     "config/emacs-application-framework.org"
  			     "config/cyz-agenda.org"
  			     "config/capture-note.org"
  			     "config/cyz-evil.org"
                               "config/term.org"
  			    ;; ,(if (cyz-emacs-for-work?)
  			    ;;      '("cyz-org-sprint.org"
  			    ;;        "cyz-work.org")
  			    ;;    ;; Personal Editor
  			    ;;    '("cyz-org-journaling.org"
  			    ;;      "cyz-feed-reader.org"))
  			     ))
    "List of org files that complete the emacs project.")
#+end_src

The list of /emacs/ org-formatted files stored in =cyz-emacs-files= is selectively short, and doesn’t include all files, for instance, certain languages that I’m learning aren’t automatically included. The function, =cyz-emacs-files= will return the list loaded at startup, as well as with an optional parameter, return them all.
#+begin_src emacs-lisp :comments link
(defun cyz-emacs-files (&optional all)
  "Return a list of my org files in my `emacs' directory."
  (if (not all)
      cyz-emacs-files

      (let ((emacs-config-org-dir "~/.emacs.d/config"))
        (thread-last (rx ".org" string-end)
                     (directory-files emacs-source-dir nil)
                     (append cyz-emacs-files)
                     (--filter (not (string-match (rx "README") it)))
                     (-uniq)))))
#+end_src

With this function, we can test/debug/reload any individual file, via:
#+begin_src emacs-lisp :comments link
(defun cyz-emacs-load (file)
  "Load or reload an org-mode FILE containing literate
Emacs configuration code."
  (interactive (list (completing-read "Org file: "
                                      (cyz-emacs-files :all))))
  (let ((full-file (expand-file-name file emacs-source-dir)))
    (when (file-exists-p full-file)
      (message ">>> %s" full-file)
      (if (called-interactively-p)
          (org-babel-load-file full-file)
        (ignore-errors (org-babel-load-file full-file))))))
#+end_src

Notice that when we call this function /non-interactively/ (e.g. from the Lisp function, =cyz-emacs-reload-all=), we suppress any errors. Obviously, I want to see the errors when calling interactively.

** Tangling the Emacs
And this similar function, will /tangle/ one of my files. Notice that in order to increase the speed of the tangling process (and not wanting to pollute a project perspective), I use a /temporary buffer/ instead of =find-file=.

#+begin_src emacs-lisp :comments link
(defun cyz-emacs-tangle (file)
  "Tangle an org-mode FILE containing literate Emacs
configuration code."
  (interactive (list (completing-read "Org file: "
                             (cyz-emacs-files :all))))
  (let ((full-file (file-name-concat emacs-source-dir file)))
    (when (file-exists-p full-file)
      (ignore-errors
        (with-temp-buffer
          (insert-file-contents full-file)
          (with-current-buffer (concat temporary-file-directory file)
            (org-babel-tangle nil nil (rx "emacs-lisp"))))))))
#+end_src

And we can now reload /all/ startup files:
#+begin_src emacs-lisp :comments link
(defun cyz-emacs-reload-all ()
  "Reload our entire ecosystem of configuration files."
  (interactive)
  (dolist (file (cyz-emacs-files))
    (unless (equal file "bootstrap.org")
      (cyz-emacs-load file))))
#+end_src

And we can tangle /all/ the files:
#+begin_src emacs-lisp :comments link
(defun cyz-emacs-tangle-all ()
  "Tangle all my Org initialization/configuration files."
  (interactive)
  (dolist (file (cyz-emacs-files))
    (cyz-emacs-tangle file)))
#+end_src
** Edit my Files
Changing my Emacs configuration is as simple as editing an Org file containing the code, and evaluating that block or expression.  Or even /re-loading/ the entire file as described above. Calling =find-file= (or more often [[file:cyz-config.org::*Projects][project-find-file]]) is sufficient but quicker if I supply a /focused list/ of just the files in my project:

#+begin_src emacs-lisp :comments link
(defun cyz-emacs-find-file (file)
  "Call `find-file' FILE.
When called interactively, present org files containing
my literate Emacs configuration code."
  (interactive (list (completing-read "Org file: "
                                      (cyz-emacs-files :all))))
  (let ((full-file (file-name-concat emacs-source-dir file)))
    (find-file full-file)))
#+end_src

Whew … and do it all:
#+begin_src  emacs-lisp :comments link
(cyz-emacs-reload-all)
#+end_src

* Technical Artifacts :noexport:
Let's provide a name so we can =require= this file:
#+begin_src emacs-lisp :exports none :comments link
(provide 'bootstrap)
;;; bootstrap.el ends here
#+end_src

Before you can build this on a new system, make sure that you put the cursor over any of these properties, and hit: ~C-c C-c~

